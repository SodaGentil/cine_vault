# 加法器

##  一位全加器 (FA)

-  **能力**：只能支持 1 bit 加 ==注意说的是每一个输入/输出端只能接收/输出1bit信号（0/1）==
    
- **实现逻辑**：
    
    - **本位和**：**S<sub>i</sub> = A<sub>i</sub> ⊕ B<sub>i</sub> ⊕ C<sub>i-1</sub>**
        
    - **向更高位的进位**：**C<sub>i</sub> = A<sub>i</sub>B<sub>i</sub> + (A<sub>i</sub> ⊕ B<sub>i</sub>)C<sub>i-1</sub>**
         ^dhtOhqRF

##  并行加法器

###  串行进位

- **实现**：将 n 个一位全加器简单串联，可支持 n bit 并行加
    
- **缺点**：进位信息是串行产生的，运算速度较慢
    

###  并行进位

- **实现**：对“串行进位”的加法器电路进行优化，增加 CLA部件
    
- **优点**：进位信息是并行产生的，运算速度更快
    

##  带标志位的加法器

- **定义**：在并行加法器的基础上，增加电路逻辑，输出 OF、SF、ZF、CF 等标志位
    

### 主要标志位详解

- **OF**
    
    - **含义**：**有符号数**的加减运算是否发生了溢出。
        
    - **判定**：OF=1 时，说明发生了溢出。
        
- **SF**
    
    - **含义**：**有符号数**加减运算结果的正负性。
        
    - **判定**：SF=0 时表示运算结果为正（SF=1 表示为负）。
        
- **ZF**
    
    - **含义**：加减运算结果是否为 0。
        
    - **判定**：ZF=1 表示运算结果为 0。
        
- **CF**
    
    - **含义**：**无符号数**加减法是否发生了溢出。
        
    - **判定**：当 CF=1 时说明发生了溢出（进位或借位）。




# 算术逻辑单元 ALU

## 功能

- **算术运算**：加、减、乘、除 等。
    
- **逻辑运算**：与、或、非、异或、移位 等。
    
- **其他**：求补码、直送 等。
    
- **注意**：总共支持 k 种功能。
    

## 实现原理

- **最简单的实现方式**：多个功能电路 + MUX，通过控制信号选通 MUX 的某个线路。
    

## 看懂 ALU 图示

### 输入

- **两个 n bit 运算数 A、B**：★ 与机器字长相同。
    
- **m bit 控制信号**：
    
    - 由控制器经过指令译码产生。
        
    - **控制信号位数**：m ≥ ⌈log<sub>2</sub>k⌉ bit。
        
- **其他输入信号**（如：来自更低位的进位信息）。
    

### 输出

- **n bit 运算结果 F**：★ 与机器字长相同。
    
- **OF/ZF/SF/CF 等标志信息**：★ 标志位信息送入 PSW 寄存器（又称 FR）。
    
- **其他输出信号**（如：往更高位的进位信息）。
    

## 考点补充

- CPU 主要由运算器、控制器组成。
    
- ALU 是运算器的核心。
    
- 加法器是 ALU 的核心（加减乘除运算都是基于加法实现的）。


# 定点数的移位运算

## 逻辑移位

- **逻辑左移**：高位移出丢弃，低位补 0。
    
    - ★ 与算术左移效果相同。
        
- **逻辑右移**：低位移出丢弃，高位补 0。
    

## 算术移位

- **算术左移**：高位移出丢弃，低位补 0。
    
- **算术右移**：低位移出丢弃，**高位补符号位**。
    

## 移位运算与乘/除运算之间的关系

### 对无符号整数

- **每逻辑左移一位**：相当于乘以 2。
    
    - 注意：若高位移出 1，则发生**溢出**。
        
- **每逻辑右移一位**：相当于除以 2。
    
    - 注意：若低位移出 1，则**丢失精度**。
        

### 对带符号整数

- **每算术左移一位**：相当于乘以 2。
    
    - 注意：若左移前后的符号位不同，则发生**溢出**。
        
- **每算术右移一位**：相当于除以 2。
    
    - 注意：若低位移出 1，则**丢失精度**。
        

### 常考

- 用左移 r 位等效实现 × 2<sup>r</sup>。
    
- 用右移 r 位等效实现 ÷ 2<sup>r</sup>。


# 定点数的加减运算

## 原码

### 加法

- **同号相加**：数值部分 = 被加数、加数的绝对值进行相加；符号位不变
    
- **异号相加**：数值部分 = 被加数、加数中，绝对值更大的减绝对值更小的；符号位与绝对值更大的数相同
    

### 减法

- 将减数取负，转变为加法
    

## 补码

- 符号位参与加法运算；减法要转变成等价的加法
    
- 注意：已知 [Y]补码，如何求 [-Y]补码？ —— 将 [Y]补码全部位取反，末位+1
    

## 溢出判断 (补码)

- **Key**：正+正=负 (上溢) ； 负+负=正 (下溢)
    
- **方法一**：V = A<sub>S</sub>B<sub>S</sub>S̅<sub>S</sub> + A̅<sub>S</sub>B̅<sub>S</sub>S<sub>S</sub>
    
    - 两个加数为正、运算结果为负时发生溢出
    - 两个加数为负、运算结果为正时溢出
        
- **方法二**：V = C<sub>S</sub> ⊕ C<sub>1</sub>
    
    - 若符号位的进位 C<sub>S</sub> 与最高数值位的进位 C<sub>1</sub> 不同则发生溢出，否则不溢出
        
- **方法三**：V = S<sub>S1</sub> ⊕ S<sub>S2</sub>
    
    - 采用双符号位补码表示数值，若运算结果的两个符号位不同则溢出，相同则未发生溢出
        
- **注**：上述三种逻辑表达式中，V=1 时溢出，V=0 时未发生溢出


# 无符号数加减运算

## 实现原理

- **加法的实现**：从最低位开始，按位相加，并往更高位进位
    
- **减法的实现**
    
    - ① “被减数”不变，“减数”全部位按位取反、末位+1，减法变加法
        
    - ② 从最低位开始，按位相加，并往更高位进位
        

## 溢出判断

- **无符号数加法的溢出判断**：最高位产生的进位=1 时，发生溢出，否则未溢出
    
- **无符号数减法的溢出判断**：减法变加法，最高位产生的进位=0 时，发生溢出，否则未溢出
    

## 溢出判断 (手算判断)

- n bit 无符号整数表示范围 0 ~ (2<sup>n</sup>)-1，超出此范围则溢出


# 无符号整数的乘法运算原理

## 本质

- 模拟无符号整数乘法的手算过程——“逐位相乘，错位相加”
    

## 运算过程

### 开始

- ① 被乘数、乘数 分别放入寄存器 X、Y
    
- ② 乘积寄存器 P 置为 0
    
- ③ 计数器 C<sub>n</sub> 的初始值置为 n，这里的 $n$ 代表的是参与运算的数字的**位数**
    

### 进行 n 轮处理

- **重复 n 轮加法、移位运算，直到计数器 C<sub>n</sub> = 0**
    
    1. **将乘数寄存器 Y 的最低位**，送入“控制逻辑”进行判断
        
    2. ① 若 Y 的最低位为 1，则执行**加法**，运算结果写回 P (注意加法产生的进位需保存至进位触发器 C) ② 若 Y 的最低位为 0，则什么也不做
        
    3. 将 [C, P, Y] 视为整体，**逻辑右移一位**
        
    4. 计数器 C<sub>n</sub> 减 1
        **每一次向右移动一位就会进行n-1**


### 结束

- 当计数器 C<sub>n</sub>=0 时，乘法运算结束
    
- 用 2n 位 [P, Y] 暂存乘法运算结果，但最终**仅保留低 n 位 [Y]** 作为最终结果
    

## 溢出判断与处理

- **溢出判断**：若丢弃的高 n 位 [P] 不全为 0，说明发生溢出，并设置 OF 标志位=1
    
- **溢出处理**
    
    - **摆烂**：程序员可以选择忽略乘法溢出，乘法结果错了也不管
        
    - **不摆烂**：也可以在乘法指令之后执行一条“溢出自陷指令”，当 OF=1 时会触发“异常处理程序”来处理溢出




# 带符号整数的乘法运算原理

## 运算过程

### 开始

- ①被乘数、乘数 分别放入寄存器X、Y
- ②乘积寄存器P 置为0，<span style="color:red">辅助位为0</span>
- ③计数器C<sub>n</sub>的初始值置为 n

### 进行 n 轮处理

- <span style="background-color:#eaeaea">重复 n 轮 <u>加/减法</u>、<u>移位</u>运算，直到计数器C<sub>n</sub> = 0</span>
- 1. 将乘数寄存器Y的最低位、辅助位，2bit 送入 “控制逻辑” 进行判断
- 2. 根据寄存器Y的最低位、辅助位，决定是 “+[x]<sub>补</sub>” “-[x]<sub>补</sub>” “+0”
- 3. 将 **【P, Y, 辅助位】** 视为整体，<span style="color:purple">**算数右移**</span> 一位
- 4. 计数器C<sub>n</sub>减1

### 结束

- 当计数器C<sub>n</sub>=0 时，乘法运算结束。用 2n 位 【P, Y】 暂存乘法运算结果，但最终**仅保留低 n 位 【Y】 作为最终结果**

## 溢出判断

- 若2n位的<span style="color:red">高 n+1 位不完全相同</span>，说明发生溢出，并设置OF标志位=1

## 溢出处理

- 摆烂：程序员可以选择忽略乘法溢出，乘法结果错了也不管
- 不摆烂：也可以在乘法指令之后执行一条“溢出自陷指令”，当OF=1时会触发“异常处理程序”来处理溢出






