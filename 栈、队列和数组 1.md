## 栈
```c
//定义栈结构
typedef struct{
    int data[MAXSIZE];//存储元素的数组
    int top;//栈顶指针
}SeqStack;
```

在数组栈中用: ** int top;而不是int *top;**

+ <font style="color:rgba(0, 0, 0, 0.85) !important;">链式栈必须用</font><font style="color:rgba(0, 0, 0, 0.85) !important;"> </font>`<font style="color:rgb(0, 0, 0);">Node* top</font>`<font style="color:rgba(0, 0, 0, 0.85) !important;">（地址指针），因为链表节点内存不连续，只能通过地址找到下一个节点；</font>
+ <font style="color:rgba(0, 0, 0, 0.85) !important;">数组栈用 </font>`<font style="color:rgb(0, 0, 0);">int top</font>`<font style="color:rgba(0, 0, 0, 0.85) !important;">（下标），因为数组内存连续，下标能更高效地定位和管理栈顶</font>



<font style="color:rgba(0, 0, 0, 0.85) !important;">假设数组 </font>`

<font style="color:rgba(0, 0, 0, 0.85);"></font>

## <font style="color:rgba(0, 0, 0, 0.85);">队列</font>


```c
// 1. 初始化队列
void InitQueue(SqQueue *Q) {
    Q->front = 0;       // 队头指针初始化为0
    Q->rear = 0;        // 队尾指针初始化为0
}
```

为什么指针初始化为0，而不是-1



```c
// 3. 判断队列是否为满
bool IsFull(SqQueue *Q) {
    // (队尾指针+1) % 最大容量 == 队头指针，则队列满
    return ((Q->rear + 1) % MAXSIZE == Q->front);
}
```

区分是队空还是队满的不同处理方式

